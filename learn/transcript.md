#SOLID
##Course Overview
Hi everyone, and welcome to my course, SOLID Software Design Principles in Java. My name is Dan Geabunea, aka the Romanian Coder. I'm a passionate software developer, clean code enthusiast, and blogger. You can find me on line at romaniancoder.com. This course is all about improving the quality, design, and maintainability of your Java applications by applying the five SOLID principles of object-oriented design, principles that each professional Java developer should understand. During this course, you'll see why technical debt is the number one challenge that many software projects face. You'll learn about the five SOLID principles. Then you'll see how to correctly identify violations of these principles and how to refactor code and correct these violations. By the end of this course, you'll be able to understand the SOLID principles of object-oriented design and apply them to create more robust systems that are easy to change and maintain over time. Before beginning this course, you should be familiar with the Java programming language at an intermediate level. From here you should feel comfortable diving into more code quality courses on design patterns and test-driven development. I hope you'll join me on this journey to create clear code with the SOLID Software Design Principles in Java course here, at Pluralsight.

##Saving the Day with SOLID
##Course Overview
Welcome to the SOLID Software Design Principles in Java Course. My Name Is Dan. I'm a Passionate Software Developer and Blogger, and I'm Really Excited to Have You on Board. In This First Module, We're Going to Look at the Many Benefits of Writing SOLID code. We'll see how SOLID principles can help us transform an application from a maintenance nightmare to a robust system that is easy to change and maintain over time. We'll start our discussion by looking at the problems that appear when SOLID principles are not used. We'll continue with describing technical debt. Then we'll define the SOLID principles and their benefits. And I'll wrap it up with a brief description of the sample application. In Clean Code, Robert C. Martin tells us that it is not enough for code to work, and, indeed, if every bug is extremely difficult to fix, if every change is very costly, if all code is an unmaintainable nightmare, then, of course, it doesn't really matter if it works for now. That project will fail sooner rather than later. And this is where SOLID principles come into play. These principles are the foundation on which we can build clean, maintainable architectures. And in this course, I'll show you when to apply them and how to apply them efficiently.

Problems That Appear When SOLID Principles Are Not Used
There are many problems that can appear when SOLID principles are not used. Let's look at a couple of examples. Let's assume we have this application with the following submodules. We have a new change request. We need to add a new payment method. So we, as developers, go ahead and implement the change. We go to the Payment module, we make the change, we then deploy our application. And after deployment, we notice that we have bugs in other subsystems. This is called code fragility. It's a term coined by Robert C. Martin, or uncle Bob. Code fragility is the tendency of software to break in many places every time you write a change to it. Let's look at the different example. We have the same application and a new change request. We need to update the reports with new information. So, again, we go to the reporting module and we start to implement the change. But, unfortunately, we cannot finish it because in order to modify the reporting module, we also have to modify other parts of the system. This is another symptom of code that is not robust, and it is called code rigidity. Rigidity is the tendency for software to be difficult to change even in simple ways. Every time we have to make a modification, a cascade of other changes needs to be done before that. Code fragility and rigidity are symptoms of high technical debt. If you encounter this in your own projects, then you most likely did not use SOLID principles when designing and architecting your application.

##Technical Debt
Technical debt is the silent killer of all software projects. Therefore, it's really important to know what it is and how we can protect ourselves against it. Although it's quite a fuzzy term, technical debt is just a cost. It's the cost of prioritizing fast delivery over code quality for long periods of time. Now think about and imagine you're working on a project. For each change or bug that you need to implement, you have a choice. You can either go for fast delivery, which is easier, it's the easiest thing that you can do to implement a change or fix the bug. It's very fast so you don't lose any time on it. It's the fastest time to delivery. But you will gain poorly written code. On the other hand, if you choose code quality, you have to spend a little bit more time to understand all the implications, try better unit tests to make your components less coupled, so you lose time. You also add a bit of complexity to your code. But, you end up with maintainable code that is easier to change and evolve over time. So this is the choice that you always have to make when implementing changes to your application. It's not realistic to think that you'll always be able to choose code quality. Sometimes we really need to get the change into production really fast, so it's okay to choose fast delivery sometimes. But if you always choose fast delivery, thus, you always sacrifice code quality, you'll end up in a point where your project can no longer evolve, and that's a really dangerous place to be in. I also think that it's easy to understand technical debt if you look at the following charts. Let's take this simple example. We have an application that we deployed, and now we have to maintain it over a couple of years. Obviously, customers will want changes during the maintenance phase. And, obviously, those changes are going to have a financial cost associated with them. In an ideal world, that cost should be kept to a minimum. That cost should be manageable at all times. However, in projects that have high technical debt, the cost of change tends to grow over time. And it grows and grows so much until it's no longer manageable. And in this chart, we can clearly see the cost of technical debt. There is a second type of cost that comes with high levels of technical debt, and that is customer responsiveness. At the beginning of a project, we are able to respond to our customers' needs really, really fast, and that keeps our customers very happy. However, in projects that have a high level of technical debt, our response time tends to grow larger and larger over the years. Again, we have a technical debt cost that is clearly seen in this chart. We need to take this cost into consideration because after we pass a specific point, that project is automatically a failure. Here are some facts about technical debt. First of all, no matter how good your team is, technical debt will accumulate over time. There is nothing you can do about that. If left uncontrolled, technical debt will slowly but surely kill your project. The only thing that you can do is to try to keep it under control. And here's how we can do that. You write some code for one of the sprints, and then you take some time to pay your technical debt. You apply SOLID principles, you apply design patterns, you refactor, you decouple your components, you write more unit tests, you do everything that you can to make your code less coupled and more maintainable. And then you write some more code, and then you take some time to pay the newly acquired technical debt. And this cycle will go on forever. That's how you keep technical debt under control.

##The SOLID Principles
We looked at the problems of legacy systems. We understood the costs of technical debt. And now it's time to focus our attention towards the SOLID principles. SOLID is an acronym for five software development principles that help us to keep technical debt under control. The five SOLID principles are the single responsibility principle, the open closed principle, the Liskov substitution principle, the interface segregation principle, and the dependency inversion principle. The first letter of each of these principles firms up the SOLID acronym. There are plenty of practical benefits for writing SOLID code. First of all, when you write SOLID code, it is easier to understand and reason about. Changes are faster and have a minimal risk level. The code is highly maintainable over long periods of time. And it is also cost-effective. SOLID in my opinion is the foundation for clean code. But there are other ways to take things to a different level. Constant re-factoring, design patterns, and unit testing are great ways to keep your application easier to change and maintain over time.

##Introducing the Sample Application
Understanding SOLID principles in theory is one thing, but knowing how and when to apply them in real applications is a completely different story. That's why I want to take a moment to discuss the sample application that we'll use throughout the rest of this course. We are going to work on a popular HR framework built by Globomantics. It is a framework that is highly appreciated by its customers because it offers features like employee management, tax calculations, pay slip generation, and reporting. I wanted to choose a domain which is really familiar but, at the same time, offers us enough opportunities to apply SOLID principles. Also, you'll have access to other source code that will be used throughout the rest of this course. Like I said, we are going to work on an HR framework. And our entrypoint to test and execute this framework is going to be a console-based application. Because we won't have any UI dependencies, we are really free to focus on what's important, and that is the business logic and how to correctly and efficiently use the SOLID principles. In this module, we saw that it's not enough to write code that works. The most successful projects are the ones that have a very large production lifespan. They're the ones where bug fixes are fast. They're the ones where changes are easy to do and don't cost a ton of money. We saw that technical debt can kill our project if left uncontrolled, and we also learned that by constant refactoring, we can pay it off and, thus, keep it under control. And last but not least, we learned about the five SOLID principles and how important they are for clean applications. They are the foundation of clean code. And in the next modules, we are going to take each one and look at it in detail.

##Understanding the Single Responsibility Principle (SRP)
The Single Responsibility Principle
We'll take a deeper look at the single responsibility principle. You'll learn what the single responsibility principle is. Then you'll be able to efficiently identify multiple reasons to change in your own codebase. You'll understand the danger of having multiple responsibilities in our methods or classes. And then we'll see a demo in which we'll refactor some legacy code and make it adhere to the single responsibility principle. The single responsibility principle has a pretty straightforward definition. Every function, class, or module should have one and only one reason to change. This definition seems pretty simple. However, it might be a little bit abstract. For example, what is a reason to change? Well, in this context, a reason to change is a synonym for responsibility. We set up a class which has a single responsibility, also has a single reason to change. So we can use these terms interchangeably. Let's take a look at some responsibilities that you've probably seen in your own applications. Business logic is one responsibility. The user interface is another. Persistence, logging are also pretty popular responsibilities. However, things like orchestration are also reasons to change. When you have a component that coordinates other components in order to achieve a particular result, that orchestration is a responsibility in itself. And also people are actors of change. And we'll see an example of this later on. One important habit that you need to develop as a software developer is the ability to identify the reasons to change that your components have and then to be able to reduce them to a single one. Now that we know what the single responsibility principle is, let's see why we should use it in our code. There are many benefits of using the single responsibility principle. First of all, it makes code easier to understand, fix, and maintain. We spend almost 90% of our time as software developers reading code, so it's pretty important to be able to understand it and reason about it very fast. And the SRP has a huge impact on readability. Then code that respects the single responsibility principle creates classes that are less coupled and more resilient to change. When we are using the single responsibility principle, we keep fragility and rigidity to very minimal levels. And, last but not least, we gain a more testable design, which is great from a quality point of view.

##Identifying Multiple Reasons to Change
I'm going to show you a couple of tricks that will help you identify multiple reasons to change in your own classes and methods. And we'll do that by looking at a couple of examples. If statements are a clear sign that the method has multiple reasons to change. We have one reason to change on the if branch and a different reason to change on the else branch. Clearly, this piece of code violates SRP. What we could do here based on the complexity of the logic is that we could extract the logic for the if branch to a separate method or class and the logic for the else branch to a different method or class. The same goes for switch statements. Each case represents one responsibility. Again, we can extract them to different methods or classes and make this piece of code more easy to read, maintain, and understand. We should also pay attention to monster methods. We can identify them quickly because they have a large number of lines of code, and also they kind of mix the levels of abstraction within the implementation. For example, this method is called getIncome. So by reading the method name, we would expect this method to return an employee income. But when we look at this method, we see that it does a whole lot of things. Indeed, it gets the income from the employeeRepository. But then it sends that income to the StateAuthority via an API. It generates a pay slip. It converts it to JSON. And then he uses that JSON and sends it via email. Obviously, this method does not do one thing. It has many responsibilities, many reasons to change, and it's very, very fragile. Also notice the many dependencies that this method has. In order to do its job, it needs to know about the StateAuthorityApi, the Payslip, about JSON format, about the EmailService. This large number of dependencies is also a clear indicator that a method or a component does more than one thing. So, each time we see a monster method, we need to identify the responsibilities and then split it into multiple methods or even classes that are more manageable and that do just one thing. We saw a couple of methods that have many reasons to change and that violate the single responsibility principle. But classes can also do that. Let's take a look at God classes. Do you have projects where you keep helper methods, classes called Utils, helpers, shared, or something like this? Well, those are classes that clearly do more than they should. A typical Utils class will look like this. We have methods to save objects to a database. We have methods for serialization. We have logging in here. We have some friendly date helpers. And each time we write a piece of code that needs a place to live but it's not important enough to have its own class, we would probably put it in one of these classes. Please don't fall into this trap. Instead, prefer having specialized classes that handle pretty clear use cases. For example, you can have a utility class that just handles dates. You can give it a very meaningful name. Then you can have classes that deal only with serialization, classes that deal only with logging, classes that deal only with persistence. Don't put everything in a single class just because it's easier or because others have done it. People are also actors of change in software applications. This method, for example, generates a report that is used by both HR and management. The report is pretty similar to both parties. But at some point in time, HR will want a specific set of features and management will want a different set of features. Because of those needs, it's far better to separate the report and make a specific report for HR and a different one for management. This way both reports will have a single reason for change. This is a more subtle case of violating the single responsibility principle. Knowing when people are responsible for a piece of code depends entirely up to you and your expertise of the business domain. But it's worth knowing that the single responsibility principle is not all about code. It's also all about the actors who use your application. Finally, let's take a look at a piece of code that has a single responsibility. Look at this class. The name is very explicit. This class is called ConsoleLogger, a very explicit name. It basically tells you that its purpose is to log information to the console. And this purpose is reinforced when we look at the two methods, logInfo and logError. Of course this is a very simple and conceived example, but this is the feeling that you should have when you're reading a component that has a well-defined purpose. The name should be explicit, the functions and features should be in line with that purpose, and everything should be very, very focused. This is a good example of a class that respects the single responsibility principle.

##The Danger of Multiple Responsibilities
I want to take a couple of minutes and discuss the dangers of writing code that has multiple responsibilities. First of all, that code is more difficult to read and reason about. Remember that we spend 90% of our time reading and understanding code. And we should make this process as easy as possible. Also, code that has many responsibilities has a poor quality because testing is far more difficult. Side effects are also a symptom of not using the single responsibility principle. Side effects are basically lies. When a function declares it does a particular thing but also does other things internally, side effects happen. And they are dangerous because most of the time they are hidden if you have to dig in the internals of an implementation to spot them. But the most dangerous symptom of not using the single responsibility principle is usually high coupling. Coupling is the level of interdependency between various software components. Components that have many reasons to change are usually tightly coupled. Coupling with concrete components is especially dangerous because it exposes you to the internal implementation of a particular class. Let's take this example. We have a getIncome method that receives an employee and, in return, that employee's income. In order to achieve this function, this class has a dependency on the repository implementation (RepositoryImpl), a concrete class. We also declare this repository internally and we construct it here. But what happens, for example, when the RepositoryImpl constructor changes? Well, of course, this piece of code will break. This introduces fragility and rigidity in our system. A better solution would have been to create an abstraction for the RepositoryImpl and pass it in as a parameter. In this scenario, the getIncome method is no longer aware of the internals of the Repository class and can do its job to get the income for a particular employee. We'll talk more about this technique when we discuss the dependency inversion principle. The key takeaway here is that if Module A knows too much about Module B, changes to the internals of Module B may break functionality in Module A. Like I said, this would introduce technical debt. Therefore, you should always pay attention to the dependencies of your particular components and try to extract them and abstract them as much as possible.

##Demo: Applying the Single Responsibility Principle
You should now have a good understanding of the single responsibility principle. But the best way to learn it is by practice. In this demo, we will refactor a component that has many reasons to change. You'll use what you've learned so far and identify the responsibilities of that component. Then you'll extract them out by applying the single responsibility principle. The Employee class is at the heart of the Globomantics HR framework, and it models an employee from a business perspective. We can see common properties like firstName, lastName, monthlyIncome, and nbHoursPerWeek. But we also have this save method over here. Take a moment to look at this method and try to spot the many responsibilities that it has. First of all, we have a serialization of the employee in order to write it to the file system. That's one responsibility. Then we have a responsibility that deals with file access. We have logging as the third responsibility, and the overall coordination of these steps, including the exception handling, as another one. Also notice that the save method deals with persistence, but the Employee class is a business entity. Therefore, the save method should not even be in this class. We should probably move it to a separate component that handles persistence. So let's go ahead and refactor this method piece by piece. Let's start by moving the save method out of the Employee class. It turns out that you already have a component that deals with persistence, and that is the EmployeeRepository. So I'm going to go ahead and paste it as is in the EmployeeRepository class. Then we need to fix it by modifying things that don't compile by using the getters from the employee, and I'm going to remove the static modifier. We have now moved the save method out of the Employee, which makes the Employee class clean and adherent to the single responsibility principle. However, this method still has multiple responsibilities. So let's go ahead and extract them piece by piece. I want to move the serialization logic out of the save method. So I'm going to copy/paste it, and I'm going to create a new class that will deal specifically with employee serialization. I'm going to call it EmployeeFileSerializer. Notice that the names I'm giving are very explicit, and that will help you keep your classes short and focused. I'm going to create this class, and then I'm going to implement the save method. Now that we go back to the Employee, I also want to extract the logging out of this method. I'm going to go ahead, and I'm going to create a new class. I'm going to call it ConsoleLogger, again, a very explicit name, and I'm going to move logging in here. Now we can come back to the EmployeeRepository and change the implementation. For that, I need a dependency on the newly created employee serializer, and I'm going to add it here. Notice that I'm injecting this dependency in the constructor so that the EmployeeRepository does not have to concern itself with constructing a concrete instance of the EmployeeFileSerializer. Then I'm going to grab my serialized string by using the newly created serializer. I'm going to remove this whole implementation, and, of course, I'm going to make the necessary adjustments for this code to work. I'm going to arrange it nice and easy, and we can already see that the save method has grown shorter. We have passed the serialization responsibility to that employee serializer. Now we also have logging and orchestration. It's not a good idea to keep exception handling and logging in the save method. I want to move it out and let the caller handle it. So I'm going to completely remove the logging and the coordination out of this method. In the end, our method should look just like this. The save method is only concerned with saving that employee to the file system. Now that our Employee respects the single responsibility principle, let's go to the caller and make the necessary modifications. In our case, the caller is the main method that saves all the employees to the file system, and we need to make it work again. We notice that we can no longer construct the EmployeeRepository. That's because the constructor also needs an EmployeeFileSerializer. I'm going to go ahead, create the FileSerializer, and inject it in the EmployeeRepository. Now that we have a repository, we also need to change the call to the save method, which is no longer happening on the Employee class because we have extracted it to the repository. So we will replace this line with repository.save, and we are going to pass in the employee. And now we have to implement the exception handling logic and the logging in here because this is the caller. I'm going to surround this block with a try/catch. I'm going to give this exception a meaningful name. In case this fails, I'm going to use the logger class and log this exception. I'm going to use our newly created logger to write this exception to the console. For that, I need to instantiate our ConsoleLogger and use it to print that exception. ConsoleLogger.writeError, and I'm going to pass in a message, and I'm also going to pass in the exception. And if everything works okay, we still need to do this logging. So I'm going to use the consoleLogger and write a message to let us know that the employee has been successfully saved. I'm going to run this application just to make sure that everything still works. We have saved four employees. And if we look here, we can see the files where they have been written. Our job here is done. We have successfully refactored the employee save method by continuously applying the single responsibility principle and breaking functionality in specific components where needed. This is a typical process of how we can refactor Code to adhere to the single responsibility principle.

##Summary
In this module, we took an in-depth look at the single responsibility principle. You saw how to correctly identify reasons of change in classes and methods. You learned that if statements, switch statements, God classes, and monster methods are all clear indications that a particular piece of code has many reasons to change and that you should do your best to refactor it. You then learned about the link between high coupling and code fragility. Code that has many reasons to change also tends to have many dependencies, which make it very brittle. And, finally, you learned how to refactor responsibilities out to specialized components in the demo. In most cases, this is a three-step approach, identifying the reasons to change, extracting them to different components which are specialized, and then re-factoring your code so that it compiles and works as expected. To quote one of my favorite books, The Pragmatic Programmer, "We always want to design components that are self-contained, independent, and with a single and well-defined purpose. " That's the essence of the single responsibility principle.

##Evolving Code with the Open Closed Principle (OCP)
The Open Closed Principle
In this module, we'll discuss about the open closed principle and how it can help us to write code that is easy to change and evolve over time. We'll start by defining the open closed principle and seeing why it is a good idea to apply it when implementing changes. Then we'll go to a demo in which we'll see how we can implement the new feature without the OCP. We'll find out why this is not such a good idea. Then we'll look at some concrete OCP implementation strategies. We'll apply these strategies in a new demo in which we will implement the C feature but this time using using the open closed principle. You will then have a pretty good idea of why you should use this principle because you can compare it to the previous demo. And we'll wrap it up with a quick discussion about how to apply the open closed principle for frameworks in API design. The open closed principle states that classes, functions, and modules should be closed for modification but open for extension. But what does closed for modification and open for extension really mean? Well, a class is closed for modification if for each feature that we need to add, we do not touch an existing source code. The source code basically becomes immutable. At the same time, a component is open for extension if it allows us to make it behave in new ways by creating or writing new code. And the open closed principle tries to re-conciliate these two mantras. Let's take a look at a conceptual example and see why modifying existing code is not such a good idea. Assume that we have a system with three classes, Classes A, B, and C. We want to implement a new feature, and we go ahead and do that by modifying code in Class A. Do notice that Classes B and C depend upon Class A. When we modified Class A by mistake, we also broke Class B because Class B was dependent on it. That's the main problem with modifying existing source code. There is a high risk of breaking other components, and this is just a very simple example. In a real application, the dependency graph is much more complex, and changes to particular components can have ripple effects in various parts of the system. Again, this is fragility. A better approach would have been to implement that change and put it in a new component. Let's call it Class D. If we do this, then we implement our feature, but we do not touch the existing system. Therefore, we have a very low risk of introducing regression bugs. You are probably starting to guess why this principle is so important, first of all, because new features can be added easily and with minimal cost. Even in legacy applications that are very tangled and old and complex, each time we need to make a change, the best way is to put that change in a separate component, write a unit test for it, and that's it. If we go ahead and start to touch old components, legacy components, then that risk that I was telling you about is very, very high. So we can use the open closed principle in every application. Then the open closed principle minimizes the risk of regression bugs. And, finally, it enforces decoupling by isolating changes in specific components because every time you need to make an important change, you put it in its own place. You can see how the open closed principle kind of works together with the single responsibility principle. And I think that's the essence of the SOLID principles because they are most effective when they are applied together.

##Demo: Downside of Adding Features by Modifying Existing Code
Understanding the dangers of modifying existing code is more evident in a real example. In this demo, we are going to add a new software feature to our HR framework without applying the open closed principle. We'll have a chance to observe how easy it is to violate it and also the problems that modifying existing code has on your software design. We'll continue to work on the Globomantics HR framework. In the Business Requirement Document, we have specifications for implementing a tax calculator. For each employee, the taxes consist of three parts, a fixed $100 amount for the base health insurance, 16% income tax, and 10% retirement tax. After reading these requirements, the initial TaxCalculator component was created. Pretty simple, we define the constants that represent the tax percentages, and then we have a calculate method which implements the specifications described in the document. Later on we add new requirements. The business guys came to us and told us that now tax calculations should be based on the type of employee. For full-time employees, the calculation remains the same. For part-time employees, we have just a 5% retirement tax instead of 10%. And for interns based on the value of their income, either no tax or just a 16% income tax. We want to implement these new requirements, and we'll do that by taking the shortest route, meaning we'll modify the existing calculate method in the TaxCalculator class to handle all the scenarios described in the Business Requirement Document. I'm going to delete the current implementation. This is what our new implementation looks like. When the employee is a FullTimeEmployee, we keep the current implementation. When the employee is a PartTimeEmployee, we apply a smaller retirement tax. And for the Interns, if they have a monthly income less than $350, there is no tax. Otherwise, just apply the income tax. You can observe how the implementation of this method has grown in complexity. It's a lot harder to follow what this method does precisely. The bad news is that if we want to add more types of employees in the future, we need to come here and modify this method as well. So this method has everything you need to become a new master method. Not only is this not a good thing, it also introduces useless risk because the TaxCalculator is used throughout our system. We need to find a different way to add these new features without constantly changing existing code.

##Open Closed Principle Implementation Strategies
You saw that modifying existing code is not the best approach when dealing with areas of an application that are very susceptible to change. Luckily for us, there is a better way to implement changes without modifying existing code, and that is by extending its capabilities. There are two great ways to do that. The first one is inheritance, and the other one is a design pattern called the strategy pattern. Take a look at this simple class. It's called BankAccount, and it exposes a feature for transferring money internally in the same country. And now we have a new request to also handle international transfers. Now the worst approach to this would be to start modifying the existing transferMoney method and put the logic for the international transfer here as well. We are not going to do that. Instead, we are going to extend the capabilities of this class. The easiest way to do that is by using inheritance. We can simply create a new class called InternationalBankAccount, which extends the BankAccount class and simply overrides the transferMoney method with business logic for international transfer. We are basically creating a new component that can handle international money transfers, but we're not touching the original BankAccount class. Inheritance is a good way to apply the open closed principle. It does, however, have a small drawback. Inheritance produces coupling between the derived classes and the base class, especially when we are using a concrete class as the base class. This is the case here. We are extending BankAccount, which is a concrete class, and inadvertently we're introducing a form of coupling. A better approach to applying the open closed principle is a design pattern called the strategy pattern. In the strategy pattern, we are not using inheritance, but we are using interfaces. So instead of creating new classes for each bank account transfer type, we are extracting that functionality into an interface. We create a new interface called MoneyTransferProc, and we declare this capability, this transferMoney capability. Then we can create classes that implement this interface. In our case, we have two classes, BankAccount and IntlBankAccount, which implement the MoneyTransferProc, and each of them can provide their own implementation for this method. However, BankAccount and IntlBankAccount are not linked in any other way. IntlBankAccount does not inherent from BankAccount. This means that these two classes can evolve independently. They have no coupling with each other. After we have our strategies, we need the factory that is capable to build them based on a particular property, like a TransferType. So we create a MoneyTransferProcessorFactory, which has one method called build. A build method receives a TransferType. It can be international, local, whatever, and it gives us back an instance of a particular MoneyTransferProc. If the TransferType is local, we have the BankAccount class. Else, we have the IntlBankAccount class. Then when we are processing payments, we can just have a generic method that takes the amount and the TransferType. The factory is going to give us a concrete instance of a particular MoneyTransferProc, and then we'll call the transferMoney method on that processor. The beauty of this is that every time we need to add new transfer capabilities, we do not need to modify this class. Nor do we need to modify existing strategies like BankAccount or IntlBankAccount. All we have to do is create a new component, implement the MoneyTransferProc interface, and provide that concrete implementation. So, which one should you choose? I propose that you take a progressive approach when applying the open closed principle. Start small in the beginning. You don't have to create new components to implement changes for the first time. Instead, make those changes inline, and then if there is a real need, extract them to different components. Also, don't apply the open closed principle for bug fixing. If you have a broken component, you should change that component and make it work as expected. If you have areas of your code that are likely to change over time, then you should probably consider one of the two alternatives for applying the OCP. Start with inheritance. If that does the trick, fine. If you need something more powerful or more flexible, then you should consider design patterns like strategy.

##Demo: Extend Software Capabilities Using the Open Closed Principle
Let's put this information to use and apply the open closed principle to the tax calculation requirements. We are going to add a new software feature using the open closed principle. We get the chance to apply the strategy pattern and see how it can be used to implement new capabilities without modifying existing code. Our new business requirements tell us that tax calculation should be done based on the employee type. In the previous demo, we tried to put all this implementation in the TaxCalculator, but that wasn't the best approach. Let's try to apply the strategy pattern and see how we can add new features without modifying existing code. The existing TaxCalculator class just handles calculations for the full-time employee. So instead of changing it, I'm just going to rename it to FullTimeTaxCalculator. Now this class has a clear and specific purpose. The next thing that I want to do is I want to extract an interface for the calculate method. I'm going to call this interface TaxCalculator. And, of course, it's going to have a simple method that will calculate taxes. I'm going to go back to the FullTimeTaxCalculator, and I'm going to make it implement the TaxCalculate interface that I've just created. We are now in a good spot to begin applying calculations for the part-time employee and the intern without having to touch this existing class. Then notice that although we have renamed it and made it implement the new interface, we did not touch the method implementation nor the internal specifications of this class. Let's go ahead and create two new classes for part-time tax calculations and employee tax calculations. I just created two new classes that implement the TaxCalculator interface, InternTaxCalculator and PartTimeTaxCalculator. We are going to use these classes to implement specific tax calculations for these employee types. Let's implement the PartTimeTaxCalculator first. I'm going to delete this _____ implementation, and I'm going to replace it with the correct one. This is what the PartTimeTaxCalculator should look like. It overrides the calculate method and provides the implementation with the correct RETIREMENT_TAX_PERCENTAGE. We'll do the same thing for the InternTaxCalculator. And there it is. The InternTaxCalculator now adheres to the internal documentation. If the monthlyIncome is less than $350, then there is no tax. Otherwise, we just apply the income tax percentage. One thing that I want to point out is that these three classes, the FullTime, Intern, and PartTimeTaxCalculators, are now very specific. They just calculate one thing, a tax for a particular type of employee. By implementing new functionality using the open closed principle, we have indirectly also applied the single responsibility principle. This is how SOLID principles work well together and reinforce one another. Now that we have three implementations, I want to create the factory that can service a concrete instance of a tax calculator based on the employee type. And this is what our factory looks like. We receive an employee as a parameter, and based on the employee type, we either return a FullTimeTaxCalculator, a PartTimeTaxCalculator, or an InternTaxCalculator. Now that we have the plumbing in place, let's go to the main method and see what changes need to be done over there. The CalculateTaxesMain class is the entry point that executes a tax calculation against all employees. We iterate over our collection of employees. We calculate the taxes. And then we format them, print them, and then add them to the company total taxes. That is the essence of this main class. However, after we've made our changes, there are some things that no longer work. First of all, the TaxCalculator instantiation can no longer work because TaxCalculator is now an interface. So we have to remove this piece of code from here. Then the TaxCalculator is created based on the employee type. So here in the for loop, we need to instantiate it using the Factory class that we just created. We pass in an employee, and then the Factory will give us a concrete instance of the TaxCalculator based on that type. Then the program works as expected. So with minimal changes, we managed to re-implement our features using the open closed principle. Let's run our application and see that it works as expected. And here are our tax calculations for each employee in our EmployeeRepository. The application works as expected. The beauty of this code is that if new employee types are to be added, we do not need to modify the main method, nor do we need to modify any of the tax calculators that we just created. We only have to create a new class that implements the TaxCalculator method and then provide the particular implementation. And that's it. The rest of the code will still work, and we won't have to touch existing code. That's the beauty of the open closed principle.

##Applying the Open Closed Principle for Frameworks and APIs
I want to take a couple of minutes to discuss a more subtle version of the open closed principle, and that is its relation to framework and API design. An API is a contract or agreement between different software components on how they should work together. JUnit, for example, is a popular testing framework. A key point here is that a public framework or API is completely under your control. Clients cannot change existing code. However, the changes that you make to that framework can impact clients because they might use it in ways that you aren't aware of. So it's important to know how to apply the open closed principle when designing frameworks or SDKs. Let's take a simple example. We are creating an HR framework, and we have a TaxCalculator that _____ an employee and calculates some taxes. You package your SDK into a JAR file, you put it on Maven, and then your clients can use it in their own applications. However, later on, you decide that you want to also include currency in the TaxCalculator, and you do that by violating the open closed principle. You basically modify the existing TaxCalculator, and you add the new parameter to the calculate method. Although your code might work, when your clients get the updated version of this framework, their code will break. Changing existing functionality in publicly exposed frameworks can have devastating effects on the consumers. How can we apply the open closed principle in this scenario? You can make your library open for extension. For example, we could extract an interface called AbstractTaxCalculator. Then in our framework, we provide some implementations from default implementations for it. And when the customers are not satisfied with the default implementations, they can just create a new class, implement the AbstractTaxCalculator that you created, and provide their own logic. This is what an extensible framework looks like. You provide your clients with interfaces that can act like extension points where they can hook up their custom logic with your framework. Here are some best practices for changing APIs. First of all, do not change existing public contracts like data classes or method signatures. Then, be sure to expose abstractions to your customers and let them add new features on top of your framework. When you expose abstract classes or interfaces, you're basically providing an extension point for your clients to provide their own custom logic and fill in the gaps of your framework. And, last but not least, if you really need to do a breaking change, give your clients time to adapt. Don't just change your API overnight without letting them know. Instead, create the new methods or the new functionality, mark the old one as deprecated, and let them know that in a particular month of time, the code that they might be using will be removed.

##Summary
In this module, we tried to look at the open closed principle from many angles. Changing requirements are inevitable in real-life applications. And the open closed principle provides an elegant way to extend functionality without modifying existing code. Modifying existing code is risky because it can incur breaking changes on other components. You saw how inheritance and design patterns are effective ways to add features without modifying existing code. OCP also applies to packages, not just to classes and methods. Each time you design a package or a framework, be sure to not break existing data contracts and also leave extension points in the form of interfaces or abstract classes that can be used to extend the package capabilities. Sometimes it is really not pragmatic to extend a component, and you really need to modify it. Bug fixing is a good example. When you're fixing bugs, it's okay to modify existing code. Also, for small changes or areas that will not evolve over time, it's okay to modify existing code. Don't go overboard with the open closed principle. Use it only when needed. Also, be aware that making a flexible design adds more complexity to your application. That's why it's important to start small and abstract later when needed. The open closed principle is all about changes. Following it will lead to elegant designs that are easy and painless to extend in the future.

##Applying Liskov Substitution Principle (LSP)
The Liskov Substitution Principle
In this module, you'll learn to apply the Liskov substitution principle, the third one in the SOLID acronym. We start by defining the Liskov substitution principle and why it is so useful to create correct type hierarchies. Then we'll look at a couple of examples where this principle is violated. After that, we will learn how to fix incorrect relationships between types. And at the end, we'll have a demo in which we'll refactor a class to respect the Liskov substitution principle. This principle has many definitions. The first one is a little bit more abstract but very accurate. If S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without modifying the functionality or the correctness of the program. It's a pretty accurate definition although a little bit abstract, especially for beginners. That's why I prefer the second definition. Any object of a type must be substitutable by objects of a derived type without altering the correctness of that program. And I want to highlight the word substitutable. The Liskov substitution principle is all about relationships between types. As humans, we have a tendency to think about relationships as "is a. " We say that a square is a kind of rectangle or an ostrich is bird. However, in object-oriented terms, this "is a" relationship is not really helpful and can even make us create incorrect hierarchies of classes. Instead, we should ask ourselves if a particular type is substitutable by another type. For example, is the class rectangle fully substitutable by the class square? Or is the class ostrich fully substitutable by the class bird in the context of our application? That's the correct question that we should ask ourselves each time we create a relationship between our types. Indeed, incorrect relationships between types cause unexpected bugs or side effects. This can be pretty tricky to spot and correct. And usually correcting them involves a lot of re-factoring and reengineering. To save time and effort, it's important to get them right in the first place, and the Liskov substitution principle will help us to achieve this.

##Detecting Violations of the Liskov Substitution Principle
The Liskov substitution principle is best understood by looking at examples of incorrect type hierarchies. Let's start with a simple one. We have a class called Bird, which has a method, fly, that receives an altitude and performs some flying logic for that particular bird. Then we create the class Ostrich that extends Bird. Ostriches can't fly. Therefore, we have to override the fly method and basically leave an empty implementation. Now, what do you think will happen when we create an ostrich like this? Then we call the fly method with an altitude of 1000. The application won't break, but this method won't produce any results. In other words, the program produces an unexpected result, and the problem comes with this incorrect relationship between the ostrich and the bird. In biology, an ostrich is a bird. But in object-oriented programming and particularly in our program, the class Bird is not fully substitutable by the class Ostrich. We created an incorrect type relationship. Let's look at another example. Each time we harden preconditions, we break the Liskov substitution principle. For example, we have a class called Rectangle with two setters for height and width. Then we have a method called calculateArea, which returns the width multiplied by the height. After that, we create a class Square which extends Rectangle because in mathematical terms, a square is a rectangle. However, in the setters, setHeight and setWidth, we harden the initial preconditions because for a square, the height and the width are equal. So each time we set the height, we also set the width and vice versa. Now in our main program, we create a new Square, we set the width, we set the height, and then we calculate the area. The result will be 400, which, of course, is correct from our program's perspective. However, if you look here at these few lines of code, something doesn't feel right because you created a new Square, the base type is rectangle, so we are able to set the width and height, but we are not expecting the hardened precondition. We're not expecting that when we set the width, the height would also be set, and when we set the height, the width will also be set. So the program behaves in an unexpected way, and that's because we have an incorrect relationship between Square and Rectangle. A rectangle is not fully substitutable by the class Square. And here's where the big problem lies. We saw examples using inheritance. However, we can violate the Liskov substitution principle when we implement interfaces. Take a look at this simple Account interface. It has two methods for processing local transfers and processing international transfers. Then we create a class called SchoolAccount, which implements the Account interface. However, in SchoolAccount, we can only transfer money locally within our country. Therefore, we add business logic there. However we cannot process international transfers, and we throw a RuntimeException to mark that this method is not supported by the SchoolAccount class. When we try to run this program like this, it will crash with an error. Again, this is because we have an incorrect hierarchy between the SchoolAccount class and the Account interface. Basically, an account is not fully substitutable by the SchoolAccount class. Each time you see a method that throws a Not implemented exception, we are violating the Liskov substitution principle. You'll see in the next module that this also violates the interface segregation principle because our class does not fully support the interface it implements. Type checking is another symptom of not adhering to this principle. Imagine that you're working on an Agile board. You have various task types including a BugFix, which is a particular type of task. You want to receive a collection of tasks and set them in progress, and you can do that for all task types except bug fixes. For bug fixes, before you are able to set any progress, you need to initialize the bug description. This kind of approach, where for most subtypes, you do one thing, but for particular subtypes, you do another thing, is an indication that those subtypes cannot substitute their base type. And, again, we are not adhering to the Liskov substitution principle. This example that I've shown over here illustrates the problems and unexpected behavior that may occur when we are not creating correct hierarchies between our types. The Liskov substitution principle can help us to fix them, and we'll see how in the next lecture.

##Fixing Incorrect Relationships between Types
Incorrect relationships between objects are a cause of subtle bugs in our application. Therefore, you need to correct them as soon as you discover them. There are two great ways to refactor code and make it respect the Liskov substitution principle. The first one is to eliminate incorrect relationships between objects. The second one is to use the "Tell, don't ask! " principle to eliminate type checking and typecasting. In the ostrich and bird example, we have a public void fly method that did nothing. This was obviously a violation of the Liskov substitution principle. We can refactor this code by breaking that relationship. Essentially, we'll have two classes, Bird and Ostrich, with their own data and capabilities that are not linked by the inheritance relationship. The Ostrich class no longer has to implement the fly method. We can apply the same principle and break the relationship between square and rectangle. We can fix partially implemented interfaces by breaking the interface down into smaller, more focused pieces. Our SchoolAccount class implements just one method of the Account interface. It does not respect the Liskov substitution principle. However, we can make SchoolAccount implement the LocalAccount interface. This interface exposes a single method, processLocalTransfer. Now our class fully implements the LocalAccount interface. And LocalAccount is fully substitutable by the SchoolAccount class. By splitting the Account interface into smaller interfaces, we've managed to create a correct relationship between SchoolAccount and LocalAccount. We'll talk more about this in the next module where we discussed the interface segregation principle. Type checking can be fixed using a principal called "Tell, don't ask! " Here in this for loop, we are basically asking if t is an instance of a BugFix. Then we're creating a task to transform t from type Task to type BugFix. We initialize the bug description, and then we go on to set the task in progress. We could simplify this and eliminate the type checking altogether by overriding the setInProgress method on the BugFix class. Here we set initializeBugDescription and then set that task in progress. Now our for loop is transformed and looks like this. We are not asking the type of t. Instead, we are telling t to perform the setInProgress action. This is the essence of the "Tell, don't ask! " principle. Here are a couple of proactive ways to apply LSP. Make sure that a derived type can substitute its base type completely. Always ask yourself this question before building a relationship between types. Don't ask the "is a" question. Don't ask yourself, Is square a rectangle? Ask yourself, Does the class Square fully substitute the class Rectangle in all the context of my application? Keep base classes small and focused. If you have a pretty large base class, then breaking the Liskov substitution principle has a higher probability. Big, fat base classes have lots of functionality and methods and make it harder to create elegant and precise inheritance trees. And, last but not least, keep your interfaces lean and focused. Don't implement interfaces that bring more behavior than you would want.

##Demo: Correct Type Hierarchies by Applying the LSP
It's time to apply what we have learned in a demo. We are going to apply the Liskov substitution principle to a component that has an incorrect type relationship. We'll observe the problems of this incorrect type hierarchy and how it affects our program as a whole. And then we will refactor that code using the Liskov substitution principle. The business people came to us to implement subcontractors in the HR framework. A subcontractor is an entity that works similarly to an employee. It has contact information like name and its own email. It has a cost in the form of a monthly income and the number of hours worked in a week. On top of that, subcontractors need to have an approved SLA before working. The SLA dictates what is the resolution time for problems on their projects and the up time for the projects. Because they are external employees, they are not eligible for time off. So after reading these requirements, it's easy to see that a subcontractor is like a kind of employee. We created the class Subcontractor that extends Employee because it makes sense. Subcontractor is like an employee but it has an SLA. However, a subcontractor cannot take time off, so we decided to throw a RuntimeException when this method is called because they're not eligible for time off. And then we have the approveSLA method, which basically checks the SLA against our company's benchmarks and returns true or false. This was the simplest implementation for the Subcontractor class. But was it the best implementation? Is this a good abstraction? Can we substitute subcontractor everywhere we see the employee type? Well, let's find out. Let's look at a couple of processes where subcontractors are involved. The first one is the ApproveSLA flow. We defined the SLA with a minimum time out percent and a maximum resolution time in days for all subcontractors. Then we grab all the employees from our repository, including a couple of subcontractors. And then we want to have their SLAs approved. But only subcontractors have SLAs. So in this for statement here, we need to check if an employee is a subcontractor, and if he is, then we approve the SLA. Now, this doesn't smell very good, but when we go ahead and run this flow, we can see that the application works as expected. So we don't give it too much thought and leave things like this. This is not the only process in our application. Let's look at the NatHolidayEmployeeTimeOff flow. Here, again, we grab all the employees from our repository, and we will want to request one day time off for each employee. If you run this flow over here, we'll get an exception. We'll get a RuntimeException: Not implemented because, if you remember, subcontractors cannot request time off. They're external people who are working for our projects; they are an abstraction. The way that we link a subcontractor with the employee really doesn't work in that particular case. Let's take a look at CalculateEmployeeTaxes. It is the program that we have used in the previous module. We grab the employees and the local currency information. And then for each employee, we calculate the taxes. We'll run this flow again, and, again, we have an exception, an Invalid employee type. And that's because we do not have a tax calculator for a subcontractor. We have calculators for full-time, intern, and part-time employees. Now we could alleviate this problem by creating a subcontractor tax calculator, but that would go against the business requirements because the business requirements dictate that subcontractors should calculate their own taxes. You can see the number of problems and side effects that were introduced when we created this abstraction. Clearly, a subcontractor is not and cannot substitute an employee. Clearly, we need to break that relationship and fix our code by making it adhere to the Liskov substitution principle. Let's break the inheritance relationship between Subcontractor and Employee. I'm going to delete all the contents of this class, and I'm going to replace it with a new implementation. Now Subcontractor is a class that has monthlyIncome, nbHoursPerWeek, email, name, a constructor, and the approvedSLA method. But it has no relationship whatsoever with employees, so we've broken down that relationship. Then we have to come here and modify the ApproveSLA flow. We cannot use the EmployeeRepository anymore because a subcontractor is not an employee. But we can create our own list of employees and treat them separately. Then we just iterate over them and approve their SLA. The other thing that we need to do is we need to correct our old classes. First of all, we cannot add subcontractors in the EmployeeRepository because they are not employees anymore. So I'm just going to delete them from here. And now let's take a look at the old programs, the CalculateEmployeeTaxesMain. This will work as expected now because we no longer have subcontractors coming out of the repository. The same goes for the Time off program. Because we don't mix employees with subcontractors, this flow will also work as it did before. Just by eliminating, just by breaking our inheritance with employee, we have been able to create a subcontractor, create the SLAMain program, and the rest of the application still works as expected. The mistake that we did after reading the specifications was the fact that we did not ask ourselves the correct question. We assumed that the subcontractor is like an employee because it had many similarities with it, so we decided to go for inheritance. We should have asked ourselves, Is an employee fully substitutable by the Subcontractor class? And the answer to that question was, No. The symptoms were there. If we ask ourselves the right questions, then we can apply the Liskov substitution principle proactively. Otherwise, we may have to come back and refactor our code by breaking incorrect relationships.

##Summary
In this module, you saw that the Liskov substitution principle is more subtle than the others. You learned to not think about relationships in terms of "is a. " Always ask yourself if a particular type is substitutable by a particular subtype. Empty methods, type checking, hardened preconditions, and not implemented exceptions are all signs that you are violating the Liskov substitution principle. Pay attention to them and take necessary action when you notice the symptoms in your code. This principle also applies for interfaces, not just class inheritance. It deals with relationships between types in a general matter. And most times, you can fix incorrect type hierarchies by breaking them. We did that with the ostrich/bird example and with the rectangle/square example as well. Real-life categories do not always map to OOP relationships. That's why we need the Liskov substitution principle to help us create correct hierarchies between objects. I would like to end this module with a funny quote from a SOLID motivational poster. "If it looks like a duck, quacks like a duck, but needs batteries, you probably have the wrong abstraction. " The Liskov substitution principle helps us to create correct hierarchies between types, which guarantee that your program will run correctly and without any undesired side effects.

##Modularizing Abstractions with the Interface Segregation Principle (ISP)
The Interface Segregation Principle
Hello again. In this module, you are going to learn how to find the perfect granularity level for your abstractions by using the interface segregation principle. We'll start by looking at a definition for the interface segregation principle. Then you'll learn to identify "fat" interfaces and the symptoms that they leave in our codebase. After that we're going to see how to refactor code that depends on large interfaces. Once you have this technique mastered, we can move on to a demo in which we'll apply the interface segregation principle to fix clients that depend on large interfaces. The interface segregation principle has a pretty simple definition. Clients should not be forced to depend on methods that they do not use. We have to split interfaces that are very large into smaller, more focused interfaces so that clients that use them will not be forced to depend on things that they do not need. In the interface segregation principle, the word "interface" does not necessarily mean a Java interface. Most of the time, this is the case. However, the interface segregation principle also applies for abstract classes or, in fact, any public method that our own class depends upon. The nice thing about the interface segregation principle is that it reinforces other SOLID principles. For example, if we keep interfaces small, the classes that implement them have a higher chance to fully substitute that interface. This is the Liskov substitution principle that we've talked about in the previous module. By applying the interface segregation principle, we are reinforcing the Liskov substitution principle. If we have large interfaces with many methods, then there's a great chance that the derived types will not fully support all those methods. Thus, they will not be fully substitutable for the base interface. Therefore, they will violate the Liskov substitution principle. Also, classes that implement small interfaces are more focused and tend to have a single purpose. So we reinforce the single responsibility principle. If you create a very large interface with many methods, then the class that implements it needs to provide a behavior for all of those methods. Therefore, it might violate the single responsibility principle and do more things than it should. These two principles also reinforce one another. Before we go on, let's look at the many benefits of applying the interface segregation principle. First of all, lean interfaces minimize dependencies on unused members and reduce code coupling. Code coupling is the number one enemy of clean code. Code coupling leads to technical debt. And technical debt is not good as you saw in the beginning of this course. Then, code becomes more cohesive and more focused, which is also a good thing. And, last but not least, this principle reinforces the use of the single responsibility principle and Liskov substitution principle. At this point, you might think that the interface segregation principle is the simplest of them all. I hope I've convinced you that the implications are deeper than they appear at first sight. By keeping interfaces small, we end up with a more decoupled system that is easier to change, maintain, and evolve over time.

##Identifying “Fat” Interfaces
Before we apply the interface segregation principle, the first thing that we need to master is to identify "fat" or large interfaces. There are a couple of symptoms that manifest themselves and that tell you precisely when an interface should be re-factored and made smaller. The first case that I want to present is interfaces with many methods. Let's take a look at the LoginService interface. We have several methods over here, and the list would go on--signIn, signOut, getUserDetails, setSessionExpiration, validateToken. Each time you see an interface that has a lot of methods, it might be a good indicator that you might need to break it down into smaller interfaces. And let's take a look at a problem. Let's say we want to create a class called GoogleLoginService. We want to implement the LoginService interface. However, because the authentication is handled by Google, we might need to implement just signIn and signOut. Methods like updateRememberMeCookie or setSessionExpiration are not valid in the context of a Google authentication. Therefore, we throw an UnsupportedOperationException and not implement them. This is a problem because the GoogleLoginService class violates the interface segregation principle and also the Liskov substitution principle. So pay attention when you have large interfaces. They might force you to create classes that do not fully support them. Another example is interfaces with low cohesion. Cohesion refers to the purpose of a particular component. When all the methods are aligned with the overall purpose of that component, then we say that those methods are cohesive. Another example, we can have an interface called ShoppingCart. ProcessPayment and checkItemInStock do not conceptually belong to a shopping cart. They probably belong to a payment processor or a stock verify service. So, again, this interface and the methods within it are not cohesive. We don't have unnecessarily a lot of methods. Just four methods is not a large number. But the methods are not cohesive with the overall purpose of the interface. And when we try to implement it, we create a class called ShoppingCartImpl, and we are forced to implement those two methods. And for processPayment, for example, we're not going to throw an exception. We're actually going to implement it, so we need to bring in a lot of dependencies. We need a PaymentService. We need the UserService. We need the EmailService. So we've effectively increased coupling a lot because we are forced to provide an implementation for the processPayment method when all we wanted was a ShoppingCartImpl. Although this class does not violate the interface segregation principle because it fully implements that interface, it does, however, violate the single responsibility principle because now the ShoppingCart has more responsibilities than it has to. Cohesion was also affected because ShoppingCart is now responsible for doing other things besides its main focus, keeping track of the items added to the basket. Like I said before, the interface segregation principle is not only about interfaces. We can have the same problems with abstract classes. Take a look at the Account class. We have three methods, getBalance for our account, processLocalPayment, and processInternationalPayment. Then we try to extend this abstract class. We have a new component called SchoolAccount, which extends Account. SchoolAccount, on the other hand, does not allow international payments, so when we override this method, we have to provide the behavior. And in this case, we're not going to throw an exception; we're not going to implement it. We're going to do nothing because we think it's better than throwing an error. Well, it's not. Again, this is a symptom that we have violated the interface segregation principle because we are taking on methods that we don't actually need. These are the most common symptoms that you'll see when dealing with fat interfaces and violations of the interface segregation principle. Let's take another look at them. Interfaces with lots of methods should definitely be a warning sign. Interfaces with low cohesion where the methods do not adhere to the overall goal of your component should also be a warning sign that should tell you you're dealing with an interface that is not properly structured, is not granular enough. Clients that throw exceptions instead of implementing methods provide a clear symptom of interface pollution. Clients that provide empty implementations are another example. And, last but not least, when a client forces implementation and becomes highly coupled, again, it's more subtle, but it's a good indicator that you're taking on more features than you need.

##Refactoring Code That Depends on Large Interfaces
Now that you know the symptoms of interface pollution, let's see what we can do to refactor code that depends on large interfaces. If you own the code, breaking interfaces is pretty easy and safe due to the possibility to implement as many interfaces as you want. Instead of having one interface with three methods, we can have three interfaces each with one method. And then the class can implement all of them to achieve the same result. So that's pretty straightforward and pretty safe. On the other hand, if you're working with external legacy code and you don't control the interfaces that you have to implement, then you cannot break them down. So you need something else. Design patterns can help you with this. The adapter pattern is particularly useful for dealing with this kind of situation because it translates, it adapts interfaces that you can't control to another interface that you can use in your own code. I want to focus on the first technique. I'll assume that we own the code. Let's see how we can refactor large interfaces and make them respect the interface segregation principle. Let's take a look at the Account interface. It has three methods, getBalance, processLocalPayment, and processInternationalPayment. As we saw in a previous example, when we try to implement various variations of Account, it doesn't necessarily work. SchoolAccount, for example, doesn't support international payments, so we are forced to either throw an exception or leave that method empty, which, of course, violates this principle. What we could do is split this interface into three lean interfaces. We can create a BaseAccount interface that exposes the getBalance method. And then we can have a LocalMoneyTransferCapability, which enables clients to process local payments. And after that, we can have an IntlMoneyTransferCapability, which enables clients to process international payments. We have more granularity in building our clients. For example, the SchoolAccount class can implement Account and LocalMoneyTransferCapability. We are no longer forced to provide an implementation for the IntlMoneyTransferCapability. Our class only overrides the methods it needs. This also leads to interface reuse. Let's assume that we need to create a class called InternationalLoanService. The loan service is not an account. It just exposes IntlMoneyTransferCapability. So we simply implement that interface and override that method. We are now using those lean interfaces in ways that we didn't think about when we first created them, and that's the good thing about having small interfaces. We can compose and reuse them however we see fit during the evolution of our product. This technique of breaking interfaces down is pretty simple. So respecting the interface segregation principle once you know the symptoms is pretty straightforward.

##Demo: Breaking down Large Interfaces Using the Interface Segregation Principle
Let's look at the interface segregation principle in practice. More precisely, we'll refactor code that uses fat interfaces and make it adhere to this principle. We'll observe the symptoms of inappropriate large interfaces. And then we'll modularize the interfaces and refactor the code using the interface segregation principle. We have a new requirement from the business analysts. We need to implement a new document called the payslip. The payslip should contain the month of income, the name of the employee, and the income of the employee for the given month. The payslip should also be an exportable document. At this stage, we are interested to export it as text, but it might be possible to extend this to other formats. As developers, after reading the specification, we go scan the code, and we come across the ExportableDocument interface. The ExportableDocument interface has three methods, toPdf, toJson, and toTxt. So because we want to export our payslip to text and in the future it might be possible to export it to other formats as well, we decide to go ahead and create our Payslip class. Let's take a look at it. We made a Payslip class that implements the ExportableDocument interface. We implemented the few properties that were required of us along with a constructor, getters, and then we went ahead to implement the ExportableDocument interface. We are interested in exporting this document text. So we provide an appropriate implementation. However, for the time being, we have no implementation for PDF and JSON format. So we go ahead and just throw an UnsupportedOperationException. We have this program that exports the payslips for all employees. We iterate over the collection of employees. We generated the payslip for each employee and for a given month. Then we get the exportableText, and we print the text to the console. This program works, but clients of our HR framework are not aware that we just implemented a couple of the methods from the ExportableDocument class. Because those methods are publicly available on payslip, they can simply call those in their programs. They might want to export a payslip to PDF. There's nothing stopping them to call the toPdf method on the Payslip class. When we try to run this program, it will obviously fail because the toPdf method is not implemented. And the program will crash with an UnsupportedOperationException. These are the kinds of problems that you might expect when dealing with large interfaces. If you want to avoid these kinds of problems in the future, we clearly need to refactor the Payslip class. And the interface segregation principle can help us to achieve this. We are going to break the ExportableDocument interface into smaller interfaces and then just use the pieces of functionality that we are interested in. I have created three new interfaces, ExportableJson, ExportablePdf, and ExportableText. The ExportableJson interface exposes the toJson method. ExportablePdf exposes the toPdf method, and ExportableText exposes the toTxt method. We can replace ExportableDocument with the format that we are interested in. In our case, it's ExportableText. In the future when we'll have to provide other formats as well, we can simply add in more interfaces for all the formats. I'm going to go ahead and delete these two methods because we do not need them anymore. Our ExportPayslip program will also work as expected, and here we can see that the Payslip class only exports the toTxt method. ToPdf and toJson are no longer available. And this is a good thing. But what happens to existing classes? For example, the WorkContract class also implemented the ExportableDocument interface. And it provided implementations for all of these formats. We can simply replace the ExportableDocument interface with the three interfaces that we just created, ExportableJson, ExportableText, and ExportablePdf. The program will also work as expected, and it will compile and run correctly. That is the great thing about splitting interfaces into more manageable pieces, we can simply implement as many as we need, and we won't break functionality in existing code. To finish our re-factoring, we need to delete the ExportableDocument interface because we no longer need it. I'm going to go ahead and delete it, and our program will still work as expected. The bottom line for this demo is that most of the time, less is more. We started out with good intentions. We wanted to reuse an existing interface. However, by doing that, we have violated the interface segregation principle. We forced future clients to implement methods that they did not need, and this choice will always lead to undesired side effects and more coupling. That's why it's always better to have smaller interfaces that are easier to compose and use.

##Summary
In this module, we took a closer look at the interface segregation principle. You saw that the ISP is closely linked with the Liskov substitution principle and the single responsibility principle. When we have large interfaces, we pose a lot of difficulties on the clients that need to implement them. Those clients can end up with more responsibilities than they should, thus violating the single responsibility principle, or may not be able to fully support the interfaces that they implement, and thus they will violate the Liskov substitution principle. Don't confuse the word "interface" in the name of this principle with an actual Java interface. Most of the time, this is the case. However, you saw that you can break the interface segregation principle by extending abstract classes or classes. Pay attention to the symptoms of large interfaces. Each time an interface has a lot of methods, when cohesion is low, when you have clients that don't implement particular methods or that become highly coupled because they're obliged to implement all of them, you need to take action. You can break large interfaces into many small and focused ones for code that you own. For code that you don't own, you can use the adapter pattern. Fat interfaces lead to inadvertent couplings between clients that ought otherwise to be isolated. Therefore, it's better to have many client-specific interfaces than one general purpose interface. And I think that's the key takeaway from the interface segregation principle.

##Decoupling Components with the Dependency Inversion Principle (DIP)
The Dependency Inversion Principle
Hello again. In this module, we'll see how to effectively decouple components by using the dependency inversion principle. In my opinion, this is the most important principle of object-oriented design because it enables us to create systems that are loosely coupled, easy to change, and maintain. We start by defining the dependency inversion principle. Then we'll write some code that respects this principle and see what it looks like. Then we'll discuss dependency injection, a popular technique in which a component does not have to bear the responsibility of creating its own dependencies. Then we'll talk about inversion of control. And after that, we'll have a demo in which we decouple components and improve testability by applying the dependency inversion principle. Let's start with a definition. The dependency inversion principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions. Also, abstractions should not depend on details. Details should depend upon abstractions. This definition is a little bit abstract in nature. Before we fully understand it, we need to ask ourselves, What is a high-level module or a low-level module? What is an abstraction. So, let's answer these questions first, and then this definition will make a whole lot of sense. High-level modules are the part of our application that bring real value. They are the modules written to solve real problems and use cases. They are more abstract in nature and map to the business domain. Most of us call this business logic. Each time you hear the words business logic, we are referring to those high-level modules that provide the features of our application. High-level modules tell us what the software should do, not how it should do it, but what the software should do. By contrast, low-level modules are implementation details that are required to execute the business policies. Because high-level modules tend to be more abstract in nature, at some point in time, we will need some concrete features that help us to get our business implementation ready. They are the plumbing for the internals of a system. And they tell us how the software should do various tasks. So, high-level modules tell us what the software should do, and low-level modules tell us how the software should do various tasks. Here are a couple of examples for low-level modules--logging, data access, network communication, and IO. These are typical examples of low-level modules, and in reality, they tend to be very concrete. When we talk about logging, we'll talk about console logging or file logging. When we talk about data access, we'll talk about relational data access or NoSQL data access. For network communication, we'll talk about ports, protocols, and so on. The idea is that these modules tend to be very concrete in their nature. In a typical system, high-level modules work together with low-level modules to deliver the business value for our customers. In this example, we have payment and user management, which are all high-level modules of an HR framework. In order for them to work, they depend upon low-level modules such as networking, notification system, data access, and security. Notice that each of these low-level modules is very concrete. We tackle networking via GPRS. And when we talk about data access, we should have a relational system. And security is implemented via OAuth. Also, the notification system uses emails. Another key point here is that high-level and low-level modules are relative concepts. For example, the notification system is a low-level module for the payment module. However, the email service is a low-level module for the notification system. So in that context, the notification system is the high-level module, and the email service is the low-level module. We tend to think about the components in this way. They're not absolute terms. They're always relative to one another. An abstraction is something that is not concrete. It's something that we as developers cannot "new" up. In Java applications, we tend to model these abstractions using interfaces and abstract classes. We have now defined all the terms that make up the definition for the dependency inversion principle. So let's take a look at how this principle actually works. Traditionally, when we depend on details, our components tend to look like this. We have high-level components, which directly depend upon low-level components. Of course, this violates the dependency inversion principle because both should depend on abstractions. Let's introduce an abstraction here. Component A, which is a high-level component, no longer depends directly on component B. It depends upon an abstraction. And component B, which is low level, also depends upon that abstraction. We have the first part of the definition of the principal here. Also, the component B abstraction should not depend on other details. I also like this schematic because it illustrates the inversion word in the dependency inversion principle name. When we depend on details, the dependency flows from the high-level component to the low-level component. When we depend on abstractions, that dependency flow is inverted as shown with the arrows of this schema.

##Writing Code That Respects the Dependency Inversion Principle
Now that we know what the dependency inversion principle is, let's see how we can write code that respects it. Let's start with this class SqlProductRepo. This class has a single method getById, which receives the productId as a string and returns the Product if it finds it in a SQL database. This is a perfect example of a low-level module. It's a concrete data access class that uses SQL to return products from the database. Then we have another class called PaymentProcessor. PaymentProcessor exposes a pay method, which also receives a productId. Then it finds that project via the SqlProductRepo and processes the payment. In this context, PaymentProcessor is the high-level module and SqlProductRepo is the low-level module. However, let's look at the downside of implementing code this way because clearly the PaymentProcessor has a direct dependency with the SqlProductRepo. We can see it here in the pay method where we actually instantiate this repo. We are newing up a new instance of the SqlProductRepo class. This clearly violates the dependency inversion principle. Now let's see how we can make this code better. The first thing that we need to do is to extract the interface for the low-level module, in our case the SqlProductRepo. We will create an interface called ProductRepo, which has the getById method. Just by looking at it, we don't know where this product is going to come from. It could come from any data source. Then the SqlProductRepo class implements the product repository (ProductRepo) and overrides the getById method with concrete details for fetching a product from a SQL database. However, we can have more concrete classes that implement this product. We can have a MongoProductRepo or an ExcelProductRepo. The ProductRepo interface is unaware of the implementation details. The PaymentProcessor now can be modified to look like this. We still have the pay method, and we get an instance of the ProductRepo interface with this factory. Then we get the product by ID and process the payment. Now our method does not directly depend on a concrete implementation of the ProductRepo. We depend on the abstraction. We depend upon the ProductRepo interface. The factory here gives us a concrete instance. It can be a SqlProductRepo, a MongoProductRepo, or an ExcelProductRepo. It doesn't really matter, and this high-level component doesn't care what instance is served at runtime as long as it respects the contract. The factory, of course, is pretty simple. It has a static method that returns an instance of a ProductRepo abstraction, in this case the SqlProductRepo. But we can modify this factory and make it more smart. For example, we can modify the create method by passing in a type argument. And now we can return varies instances of ProductRepo based on that type. For example, if the type equals Mongo, we can return a MongoProductRepo. Else, we can return a SqlProductRepo. The consuming code will not care what particular instance is returned. Ultimately after applying the dependency inversion principle, our components look like this. We have the PaymentProcessor, which is the high-level module. At the bottom we have the SqlProductRepo class, which is the low-level module. And in between we have the ProductRepo interface. Both modules depend on the ProductRepo abstraction, and the abstraction itself does not depend on any details. So we have applied the dependency inversion principle to our particular case. More importantly, we have eliminated the coupling between PaymentProcessor and the SQL implementation of the ProductRepo.

##Dependency Injection (DI)
Let's take a couple of minutes to discuss dependency injection. Dependency injection is very used in conjunction with the dependency inversion principle. However, they are not the same thing. Let's look at how we left the PaymentProcessor class. We have the pay method, and the ProductRepo abstraction is now produced by the ProductRepoFactory. Although we have eliminated the coupling with the concrete SqlProductRepo class, we still have a small coupling with the ProductRepoFactory. We have more flexibility after applying the dependency inversion principle, but I'm pretty sure we can do a better design than this. Let's come up with a better solution. This is where our dependency injection comes in. Dependency injection is a technique that allows the creation of dependent objects outside of a class and provides those objects to a class. We have various methods of doing this. One of them is by using public setters to set those dependencies. However, this is not a good approach because it might leave objects in an uninitialized state. A better approach is to declare all the dependencies in the component's constructor like we are doing here. The PaymentProcessor class now has a constructor that accepts a ProductRepo abstraction as a parameter. The ProductsRepo then becomes a private field of the PaymentProcessor class. We can then use the repository to get a product by ID and process the payment. The PaymentProcessor class is no longer responsible for creating its own dependencies. It is the caller's job to provide those dependencies. Here we can imagine we have the main method. We create a new instance of a ProductRepo by using the factory, and then we create a PaymentProcessor instance bypassing that repo instance to the PaymentProcessor constructor. We can then call the pay method. This is how we use dependency injection in order to decouple our components even more. Let's look at a more complex example. We have five classes over here. Classes A and B have no dependencies whatsoever. Class C depends on class A. Class D has a dependency on class B. And class E has a dependency on both classes C and D. If you want to call a method on class E, we also need to create all the dependencies that it needs. We need to take care of all of that dependency handling. We need to create concrete instances of those classes in a particular order. We have to create classes A and B first because they have no dependencies, then classes C and D. And at the end, you can create class E and call a method on it. This is a pretty simple example with just five classes. But our real projects have hundreds if not thousands of classes that can be instantiated. Although dependency injection is a pretty cool technique, doing it manually is clearly not the way to go forward. We cannot tackle this much complexity by hand. Also, think about the lifecycle of these objects. Maybe we want A and B to be singletons and C, D, and E to be objects that are created on every request. How do we do that manually? Well, even more logic has to come into the creation of these objects. Clearly, we need something else. Luckily for us, there's another piece to this puzzle, and that piece is called the inversion of control principle.

##Inversion of Control (IoC)
Inversion of control can help us create large systems by taking away the responsibility of creating objects. Inversion of control is a design principle in which the control of object creation, configuration, and lifecycle is passed to a container or framework. The control of creating and managing objects is inversed from the programmer to this container. We don't have to "new" up objects anymore. Something else creates them for us, and that something else is usually called an IoC container or DI container. The control of object creation is inverted. It's not the programmer but the container that controls those objects. It makes sense to use it for some objects in an application like services, data access, or controllers. However, for entities, data transfer objects, or value objects, it doesn't make sense to use an IoC container. We can simply "new" up those objects, and it's perfectly okay from an architectural point of view. There are many benefits in using an IoC container for your system. First of all, it makes it easy to switch between different implementations of a particular class at runtime. Then, it increases the programs modularity. And, last but not least, it manages the lifecycle of objects and their configuration. For example, you can decide that some objects should be singletons while other objects should be created per every web request. I think that Spring is the most popular Java framework out there. At the core of the Spring framework is the Spring IoC container. You've probably heard about Spring beans. They are objects used by your application that are managed by the Spring IoC container. They are created with the configuration that you supply for that container. There are many ways to configure an IoC container in Spring. XML is one example. Creating configuration classes is another. Or simply by annotating classes with special annotations like atService, atComponent, atRepository, and so on and so forth. Let's look at a simple Spring bean definition example. We'll take the Configuration class approach. We have this normal class called DependencyConfig. We annotated with @Configuration to make it visible to the Spring IoC container. Like I said before, beans are just normal classes that are managed by the Spring IoC container. Classes A and B are classes with no dependencies. We declare them here with a @Bean annotation. Class C has dependencies on class A and class B. We are using the @Bean annotation, and we are passing the A and B arguments to the constructor of type C. Notice that we are not creating new types for A and B. We let the IoC container handle the creation of A and B for us. Then class C looks something like this. It has two private fields, A and B, and a constructor. When we need an instance of this class, the Spring IoC container will look at the constructor. It then extracts the dependencies that class needs, in our case A and B. Because we declared A and B as beans in the configuration class, the Spring IoC container can inject them over here, and thus it can create an instance of class C. This whole process of creating, handling dependencies, and creating objects has been taken away from the programmer. The Spring IoC container manages it very well. Let's finish this lecture with a small recap. A dependency inversion principle, dependency injection, and inversion of control work very well together and are the most effective way to eliminate coupling. They are not, however, the same thing, and sometimes they will get confused. The dependency inversion principle tells us that high-level modules should not depend on lower-level modules. They should both depend upon abstractions. Dependency injection is a technique in which a component is not responsible for the creation of its own dependencies. Rather, it can declare those dependencies in the constructor, and in the calling code, a programmer or another framework can inject them. Manually handling and creating dependencies is not scalable, especially for large applications. This is where an inversion of control container comes in. It can handle the creation and lifecycle of all the objects in our application.

##Demo: Refactoring Code with the Dependency Inversion Principle
It's time to write some code and apply what we have learned so far. In this demo, we'll apply the dependency inversion principle. In the process, we'll decouple a high-level component from a low-level component using abstractions, and we'll also improve the testability of our application. In order to understand the dependency inversion principle, we are going to look at the payment processing feature of the Globomantics HR framework. This system is to retrieve all the employees and pay their incomes. Upon completion, the total paid sum must be calculated and compared with the finance department. Also, each employee should receive an email after the income payment was sent successfully. To implement this feature, we have created the PaymentProcessor class, which is located in the payment package. The PaymentProcessor is the class responsible for paying the incomes of all employees. It has a sendPayments method, which gets all the employees from the EmployeeFileRepository. Then for each employee, it calculates the payment and sends a notification via email. This component is highly coupled with the EmployeeFileRepository and the email service. Right here in the PaymentProcessor constructor, we can see that this high-level component is actually creating its own dependencies. We also have a dependency on EmailSender. We don't new up a new instance of EmailSender, but static method calls are also a sign of coupling. We can say without a doubt that the PaymentProcessor class is very aware of its implementation details. Let's take a look at the EmployeeFileRepository. We can find it in the persistence package. The method that we are interested in in the EmployeeFileRepository is the findAll method. This method opens the employees.csv file, which is located on the resources folder, and then it reads each line and creates an employee from each CSV line in there. Now let's take a look at the EmailSender class located under the notifications package. The EmailSender has one public static void method called notify, which receives an employee. It creates all the properties of the email server. Then we construct the MimeMessage, and then we send that message and print out something to the console. This class will actually send emails to a test server configured via Mailtrap. The PayEmployeesMain program is the place where we instantiate the PaymentProcessor and then call the sendPayments method. This program works, but our application is very, very coupled. Going back to the PaymentProcessor, you have to ask yourself, What's going to happen if a particular client doesn't want to read employees out of a CSV file? What is going to happen, for example, if he wants to read employees from a SQL database? What happens if a particular client doesn't want his employees to receive emails, but text messages or slide notifications? The way we have written our code, it's impossible to reconfigure this behavior at runtime. PaymentProcessor initializes its own EmployeeRepository and depends directly on the EmailSender. So the only way we could achieve this is to come here and modify this class. So we're not only violating the dependency inversion principle, we're also violating the open closed principle. Testing is also affected with this high level of coupling. Let's take a look at the test for a PaymentProcessor class. We want to test the PaymentProcessor, so we put the test under test, java, hr.payment. This test class has a single test method. SendPayments should pay only employee salaries. Here we create an instance of the PaymentProcessor. Then we execute the sendPayments method. Then we assert that the result is equal to $5, 440. We computed the result by looking at the employee's CSV file. This CSV file contains the names, incomes, and number of hours worked per week for each employee. We calculated all the incomes, and the value was $5, 440. That's the value that we used in our test. Let's go ahead and run this test. The test was executed with success. However, I would argue that this is not a good test. What do you think is going to happen if we start to modify the incomes of some employees or if we delete an employee? Obviously, the total salaries that are going to be paid is not going to be equal to $5, 440. So our test is going to fail. Also, what is going to happen if you're running this test in a build environment where we don't have access to the internet. Well, the email sender is not going to work. It's going to throw an exception. So our test is also flaky. If we have an internet connection and a correct main server configured, it's going to pass. Otherwise, it's going to fail. All that we wanted was to test the PaymentProcessor class. We're interested to see if the total amount of salaries paid is equal to the sum of salaries of all employees. We don't care how those employees are retrieved. We don't care how those employees are notified. All these problems are caused by coupling. We can't evolve the PaymentProcessor, and we cannot write stable unit tests for it. Let's fix our design by applying the dependency inversion principle. Right now our high-level component PaymentProcessor depends on low-level modules, such as the EmployeeFileRepository and the EmailSender. We need to break these dependencies. We need to make them both depend upon abstractions. I went ahead and created two new interfaces, EmployeeRepository and EmployeeNotifier. EmployeeRepository is declaring two methods, findAll and save. EmployeeNotifier defines the notify method. Let's look at the concrete classes and see how they have changed. EmployeeFileRepository now implements the EmployeeRepository interface. No additional change has been done to this class. The interface still provides the findAll and save methods. The EmailSender class now implements the EmployeeNotifier interface that we just created. The notify method is no longer static. That is the only change we did to this class. The rest of the implementation remains the same. Right now developer components depend upon abstractions. Let's look at the high-level component, the PaymentProcessor. The PaymentProcessor now has two dependencies on abstractions, EmployeeRepository and EmployeeNotifier, both interfaces. We also used the dependency injection technique in the PaymentProcessor constructor. This constructor now expects two types, an EmployeeRepository and an EmployeeNotifier, to be passed by the calling component. An implementation with sendPayments method remained almost identical. Although the code doesn't seem to have changed a lot, the implications are huge. PaymentProcessor can now be modified at runtime. We can pass various instances of EmployeeRepository. You can pass in a FileRepository, a SqlRepository. We can also pass in various instances of an EmployeeNotifier. We can pass the EmailSender, or we can pass a slide notifier or a text notifier. The code is no longer coupled. The high-level components and low-level modules both depend upon abstractions. The PayEmployeesMain method changed a little bit. Because you are using dependency injection and this is the calling component, we need to create those dependencies here. So we are creating instances for EmployeeRepository and EmployeeNotifier. We are using those dependencies to create the PaymentProcessor, and then we execute the sendPayments method. Testability has improved. Because the PaymentProcessor depends on abstractions, we can mock those dependencies and pass them in the constructor, thus bypassing the need to read employees from a CSV file and to send actual emails. We are doing this in this beforeAll method. Generally, you need to call this method before executing each test in this class. Here we define a fixed list of employees for testing purposes. We no longer read them from the CSV file. Then we create an employeeRepositoryMock. A mock is a fake object for which we can provide behavior in the test phase. When we call the findAll method on this employeeRepositoryMock, we return the testEmployees. We also mock the email notifier because we don't want to send the real emails in this test. The test method changed a little bit. We are creating a new PaymentProcessor passing in the two mocks that we just created. Then we call the sendPayments method, and we assert that the total payments is equal to $1, 700. This is actually the sum of all the incomes for the employees defined over here. We now have control over the employees. Because you don't read them from a file, this test is going to be stable. Changes in production will not affect our test. Also, because you're not using a real email service, it doesn't matter where we'll run this test. This test will always execute. So let's go ahead and run it. The test worked as expected. Also notice the speed of this test. It now executed in 37 ms, way faster than the previous one. This is how we can apply the dependency inversion principle and the dependency injection technique to break coupling between high-level modules and low-level modules. It is always better to depend upon abstractions. Code becomes less coupled, testability increases, and your overall design is more flexible and modular.

##Summary
In this module, we learned that classes should always depend on abstractions and not on implementation details. The dependency inversion principle, dependency injection, and inversion of control work hand in hand to eliminate coupling and make your applications less brittle. Testability can be greatly improved by using the dependency inversion principle and the dependency injection technique. If you make all your high-level components depend on abstractions, declare your dependencies in the constructor, and use a good mocking framework, then you have all the chances to create robust, solid, and predictable unit tests. If you're developing your applications using Spring, then you have to take advantage of the powerful capabilities of the Spring IoC container. Large enterprise applications cannot be written, in my opinion, without inversion of control, and the Spring IoC container is pretty, pretty powerful. There is a pretty cool catchphrase from Steve Smith that I really like, "New is glue. " When your high-level components create their own dependencies or new up their own dependencies, then code coupling starts creeping into your application. Code coupling brings technical debt, so your system is going to suffer from rigidity and fragility. It's much better to make high-level components depend on abstractions and leave the creation of objects to a completely different framework. A dependency inversion principle, dependency injection, and IoC are the most effective ways to eliminate code coupling and keep systems easy to maintain and evolve.

##Course Summary and Key Takeaways
Congratulations for reaching the end of this course. I want to take a couple of minutes to recap some key takeaways. As you saw, technical debt is the silent killer of software projects. Coupling is the main reason of technical debt. If you have high levels of code fragility and code rigidity, it's probably caused by high coupling. SOLID principles are a great way to tackle coupling and promote designs that can evolve and grow over time. The SOLID principles of object-oriented design are the foundation of clean system architectures, but they're not the only tool that you can use. I like to call this the pyramid of clean code. The SOLID principles are the foundation. On top of that, you can find design patterns. Then you have test-driven development. And on top we have continuous refactoring. Remember that you always have to pay your technical debt. Otherwise, it will grow out of control, and it will bring your projects to a halt. These techniques can be used individually, but they work best when you apply them together. In fact, if you're new to design patterns and test-driven development, here are a couple of great courses on Pluralsight that can help you. The first one is the Design Patterns in Java series by Bryan Hansen. The second one is Test Driven Development Practices in Java by Mike Nolan. These are great courses that will help you build your arsenal of clean code techniques. In the end, I would like to tell you that you can find all the source code that you have seen throughout these modules at GitHub by following this link. I really hope that you had fun watching this course. You should now be able to use the SOLID principles in your own projects to write solid, clean code. Until next time, have a great day and write amazing code.